// Helpers available to modes
export const math = {
  gcd(a, b) { return b === 0 ? Math.abs(a) : math.gcd(b, a % b); },
  lcm(a, b) { return Math.abs(a * b) / math.gcd(a, b); },
};

// Shared game wiring; takes a mode config {title, generateQuestion, nextDelayMs?, flashMs?}
export function setupGame({ title, generateQuestion, nextDelayMs = 250, flashMs = 150 }) {
  const $ = (s, r = document) => r.querySelector(s);
  const $$ = (s, r = document) => Array.from(r.querySelectorAll(s));

  const titleEl = $("h1");
  const questionEl = $("#question");
  const answerEl = $("#answer");
  const feedbackEl = $("#feedback");
  const buttons = $$(".numpad button");
  const clearBtn = document.querySelector("#clearBtn");
if (clearBtn) {
  clearBtn.addEventListener("click", () => {
    handlePress({ action: "clear" });
  });
}


  let currentAnswer = null;
  let lastQuestionKey = null;
  let questionStartAt = performance.now();

  function getQuestionKey(q) {
    if (q && typeof q.key === "string" && q.key.length) return q.key;
    if (q && typeof q.latex === "string" && q.latex.length) return `L:${q.latex}`;
    if (q && typeof q.text === "string" && q.text.length) return `T:${q.text}`;
    // Fallback: stringify stable fields if present
    try {
      return JSON.stringify({ t: q?.text ?? null, l: q?.latex ?? null });
    } catch {
      return String(Math.random()); // ensure progress even if unkeyable
    }
  }

  function flash(btn) {
    btn.classList.add("active");
    setTimeout(() => btn.classList.remove("active"), flashMs);
  }

  function newQuestion() {
    // Avoid showing the exact same question twice in a row
    let q = generateQuestion();
    let key = getQuestionKey(q);
    let guard = 0;
    while (lastQuestionKey !== null && key === lastQuestionKey && guard < 5) {
      q = generateQuestion();
      key = getQuestionKey(q);
      guard++;
    }
    lastQuestionKey = key;
    const { text, latex, answer } = q;
    if (typeof generateQuestion.getLevel === "function") {
      console.log("[Level]", generateQuestion.getLevel());
    }
    currentAnswer = answer;
    // Prefer LaTeX rendering if provided and KaTeX is available
    if (latex && window.katex) {
      questionEl.innerHTML = "";
      try { katex.render(latex, questionEl, { throwOnError: false }); }
      catch { questionEl.textContent = text ?? String(latex); }
    } else {
      questionEl.textContent = text ?? (latex ? String(latex) : "");
    }
    answerEl.value = "";
    feedbackEl.textContent = "";
    questionStartAt = performance.now();
  }
  let streak = 0;
  let fastStreak = 0;
  let lastCorrectAt = performance.now();

  // Time-based leveling parameters
  const TARGET_MS = 5000;  // 5 seconds sweet spot
  const MAX_STEP = 3;      // clamp level change per question


  function checkAnswer() {
    const guess = parseInt(answerEl.value, 10);
    if (!Number.isFinite(guess)) return;

    if (guess === currentAnswer) {
      feedbackEl.textContent = "âœ… Correct!";

      // --- NEW: time + streak-based leveling ---
      const now = performance.now();
      streak++;

      if (typeof generateQuestion.bumpUp === "function") {
        const dt = now - lastCorrectAt;
        if (dt < FAST_MS) {
          fastStreak++;
        } else {
          fastStreak = 0;
        }
        if (streak >= STREAK_N || fastStreak >= FAST_N) {
          generateQuestion.bumpUp();
          streak = 0;
          fastStreak = 0;
        }
        console.log(`[Speed] dt=${dt.toFixed(0)}ms  streak=${streak}  fast=${fastStreak}`);
      }
      lastCorrectAt = now;
      // --- END NEW ---

      setTimeout(newQuestion, nextDelayMs);
    } else {
      feedbackEl.textContent = "â†©ï¸ Try again!";
      streak = 0;       // reset on miss
      fastStreak = 0;   // reset on miss
      // (rest unchanged)

      answerEl.classList.add("wrong");
      setTimeout(() => answerEl.classList.remove("wrong"), 150);
    }
  }



  // Shared action handler (used by both pointer and keyboard)
function handlePress({ digit = null, action = null }) {
  if (digit !== null) {
    answerEl.value = (answerEl.value === "0") ? digit : (answerEl.value + digit);
  } else if (action === "clear") {
    answerEl.value = "";
  } else if (action === "back") {
    answerEl.value = answerEl.value.slice(0, -1);
  } else if (action === "neg") {
    if (answerEl.value.startsWith("-")) {
      answerEl.value = answerEl.value.slice(1);
    } else {
      answerEl.value = "-" + answerEl.value;
    }
  } else if (action === "enter") {
    checkAnswer();
  }
}


  // Pointer/touch: instant
  buttons.forEach(btn => {
    btn.addEventListener("pointerdown", (e) => {
      e.preventDefault(); // avoid ghost clicks
      flash(btn);
      const d = btn.dataset.digit;
      const action = btn.dataset.action;
      handlePress({
        digit: d !== undefined ? d : null,
        action: action || null
      });
    }, { passive: false });
  });

  // Keyboard: call the same handler (no .click())
  document.addEventListener("keydown", (e) => {
    const k = e.key;

    if (/^\d$/.test(k)) {
      // flash the matching button for feedback
      const btn = buttons.find(b => b.dataset.digit === k);
      if (btn) flash(btn);
      handlePress({ digit: k });
      return;
    }

    if (k === "Enter") {
      const btn = buttons.find(b => b.dataset.action === "enter");
      if (btn) flash(btn);
      handlePress({ action: "enter" });
      return;
    }

    if (k === "Backspace") {
      const btn = buttons.find(b => b.dataset.action === "back");
      if (btn) flash(btn);
      e.preventDefault();
      handlePress({ action: "back" });
      return;
    }

    if (k.toLowerCase() === "c") {
      const btn = buttons.find(b => b.dataset.action === "clear");
      if (btn) flash(btn);
      handlePress({ action: "clear" });
    }

    if (k === "-") {
    const btn = buttons.find(b => b.dataset.action === "neg");
    if (btn) flash(btn);
    handlePress({ action: "neg" });
    return;
  }
  });

  newQuestion();
}

